import { Server as SocketIOServer } from 'socket.io'
import type { NitroApp } from 'nitropack'
import jwt from 'jsonwebtoken'
import { Game } from '../models/Game'
import { GameService } from '../services/GameService'
import { BotService } from '../services/BotService'

// Global IO instance
let io: SocketIOServer | null = null

// Turn timers tracking
const turnTimers = new Map<string, NodeJS.Timeout>()

// Helper: Check if a player is a bot
const isBot = (username: string): boolean => {
  return username.includes('Bot') ||
         username.includes('AI') ||
         username.includes('Algorithm') ||
         username.includes('CPU') ||
         username.startsWith('Bot (')
}

// Timer functions
const startTurnTimer = (gameCode: string, playerId: string, gameId: string) => {
  const timerKey = `${gameId}-${playerId}`
  clearTurnTimer(timerKey)

  const timerId = setTimeout(async () => {
    try {
      const game = await Game.findById(gameId)
      if (!game) return

      const currentPlayer = game.players[game.currentPlayer]
      if (currentPlayer.userId.toString() !== playerId) return

      // Auto-play income (safest action)
      console.log(`â° Turn timeout for ${currentPlayer.username}, auto-playing income`)

      if (io) {
        io.to(`game-${gameCode}`).emit('turn-timeout', {
          playerId,
          autoAction: 'income',
          message: 'Temps Ã©coulÃ© - Income automatique'
        })
      }
    } catch (error) {
      console.error('Turn timer error:', error)
    }
  }, 30000) // 30 seconds

  turnTimers.set(timerKey, timerId)
}

const clearTurnTimer = (timerKey: string) => {
  const timerId = turnTimers.get(timerKey)
  if (timerId) {
    clearTimeout(timerId)
    turnTimers.delete(timerKey)
  }
}

export default defineNitroPlugin((nitroApp: NitroApp) => {
  const config = useRuntimeConfig()
  const JWT_SECRET = config.jwtSecret || 'your-secret-key-change-in-production'

  // Create Socket.IO server attached to Nitro's HTTP server
  io = new SocketIOServer(nitroApp.h3App.websocket.server, {
    cors: {
      origin: '*',
      methods: ['GET', 'POST']
    },
    path: '/socket.io/',
    transports: ['websocket', 'polling']
  })

  console.log('âœ… [SOCKET] Socket.IO integrated into Nuxt server')

  // Authentication middleware
  io.use((socket, next) => {
    const token = socket.handshake.auth.token

    if (!token) {
      console.log('âš ï¸ [SOCKET] No token provided, connecting as guest')
      socket.data.userId = null
      socket.data.username = 'Guest'
      return next()
    }

    try {
      const decoded = jwt.verify(token, JWT_SECRET) as any
      socket.data.userId = decoded.userId
      socket.data.username = decoded.username
      console.log(`âœ… [SOCKET] Authenticated: ${decoded.username} (${decoded.userId})`)
      next()
    } catch (error: any) {
      console.warn(`âš ï¸ [SOCKET] Invalid token, connecting as guest:`, error.message)
      socket.data.userId = null
      socket.data.username = 'Guest'
      next()
    }
  })

  io.on('connection', (socket) => {
    console.log(`ðŸ”Œ [SOCKET] Client connected: ${socket.id}`)

    // Join game room
    socket.on('join-game', async (gameCode: string) => {
      try {
        socket.join(`game-${gameCode}`)
        console.log(`ðŸŽ® [SOCKET] ${socket.data.username} joined game ${gameCode}`)

        const game = await Game.findOne({ code: gameCode })
        if (game) {
          socket.emit('game-state', game)

          // Notify others
          socket.to(`game-${gameCode}`).emit('player-joined', {
            playerId: socket.data.userId,
            username: socket.data.username
          })
        }
      } catch (error: any) {
        console.error('Join game error:', error)
        socket.emit('error', { message: error.message })
      }
    })

    // Leave game room
    socket.on('leave-game', (gameCode: string) => {
      socket.leave(`game-${gameCode}`)
      console.log(`ðŸ‘‹ [SOCKET] ${socket.data.username} left game ${gameCode}`)
    })

    // Player ready status
    socket.on('player-ready', async (data: any) => {
      const { gameCode, isReady } = data

      let username = socket.data.username
      if (!username && gameCode) {
        try {
          const game = await Game.findOne({ code: gameCode })
          const player = game?.players.find(p => p.userId?.toString() === socket.data.userId)
          username = player?.username || 'Unknown'
        } catch (error) {
          username = 'Unknown'
        }
      }

      console.log(`ðŸŽ® [SOCKET] Player ready changed: ${username} - ${isReady}`)

      io?.to(`game-${gameCode}`).emit('player-ready-changed', {
        playerId: socket.data.userId,
        username: username,
        isReady
      })
    })

    // Start game
    socket.on('start-game', async (data: any) => {
      const { gameCode } = data

      try {
        const game = await Game.findOne({ code: gameCode })
        if (!game) {
          return socket.emit('error', { message: 'Game not found' })
        }

        // Distribute cards and update phase
        game.phase = 'playing'
        await game.save()

        console.log(`ðŸš€ [SOCKET] Game ${gameCode} started`)

        io?.to(`game-${gameCode}`).emit('game-started', { game })
      } catch (error: any) {
        console.error('Start game error:', error)
        socket.emit('error', { message: error.message })
      }
    })

    // Execute action
    socket.on('execute-action', async (data: any) => {
      try {
        const { gameId, actionType, targetId, claimedRole } = data

        console.log(`ðŸŽ¯ [SOCKET] Action: ${actionType} by ${socket.data.username}`)

        const result = await GameService.executeAction(
          gameId,
          socket.data.userId,
          actionType,
          targetId,
          claimedRole
        )

        const game = await Game.findById(gameId)
        if (!game) return

        // Clear any existing turn timer
        clearTurnTimer(`${gameId}-${socket.data.userId}`)

        // Broadcast to all players
        io?.to(`game-${game.code}`).emit('action-executed', {
          game: result.game,
          action: result.action,
          needsResponse: result.needsResponse,
          canBeBlocked: result.canBeBlocked,
          canBeChallenged: result.canBeChallenged,
          blockingRoles: result.blockingRoles || []
        })

        // Broadcast to lobby to update game list
        io?.emit('game-updated', {
          code: game.code,
          playerCount: game.players.length,
          phase: game.phase
        })

      } catch (error: any) {
        console.error('Execute action error:', error)
        socket.emit('action-error', { message: error.message })
      }
    })

    // Challenge action
    socket.on('challenge-action', async (data: any) => {
      try {
        const { gameId, challengerId } = data

        console.log(`âš”ï¸ [SOCKET] Challenge by ${socket.data.username}`)

        const result = await GameService.challengeAction(gameId, challengerId)
        const game = await Game.findById(gameId)
        if (!game) return

        io?.to(`game-${game.code}`).emit('challenge-resolved', {
          game: result,
          success: true,
          challengerId,
          revealedCard: result.revealedCard
        })
      } catch (error: any) {
        console.error('Challenge action error:', error)
        socket.emit('action-error', { message: error.message })
      }
    })

    // Block action
    socket.on('block-action', async (data: any) => {
      try {
        const { gameId, playerId, blockingRole } = data

        console.log(`ðŸ›¡ï¸ [SOCKET] Block with ${blockingRole} by ${socket.data.username}`)

        const result = await GameService.blockAction(gameId, playerId, blockingRole)
        const game = await Game.findById(gameId)
        if (!game) return

        io?.to(`game-${game.code}`).emit('block-declared', {
          game: result,
          blockerId: playerId,
          blockingRole
        })
      } catch (error: any) {
        console.error('Block action error:', error)
        socket.emit('action-error', { message: error.message })
      }
    })

    // Accept action
    socket.on('accept-action', async (data: any) => {
      try {
        const { gameId } = data

        console.log(`âœ… [SOCKET] Action accepted by ${socket.data.username}`)

        const result = await GameService.resolveAction(gameId)
        const game = await Game.findById(gameId)
        if (!game) return

        io?.to(`game-${game.code}`).emit('action-resolved', {
          game: result
        })
      } catch (error: any) {
        console.error('Accept action error:', error)
        socket.emit('action-error', { message: error.message })
      }
    })

    // Disconnect
    socket.on('disconnect', async () => {
      console.log(`ðŸ”Œ [SOCKET] Client disconnected: ${socket.id}`)

      if (!socket.data.userId) return

      try {
        const game = await Game.findOne({
          'players.userId': socket.data.userId,
          phase: 'playing'
        })

        if (game) {
          const player = game.players.find(p => p.userId.toString() === socket.data.userId)
          if (player) {
            player.isConnected = false
            player.disconnectedAt = new Date()
            await game.save()

            io?.to(`game-${game.code}`).emit('player-disconnected', {
              playerId: socket.data.userId,
              playerName: player.username
            })

            // Replace with bot after 60 seconds
            setTimeout(async () => {
              const freshGame = await Game.findById(game._id)
              if (!freshGame) return

              const freshPlayer = freshGame.players.find(p => p.userId.toString() === socket.data.userId)
              if (freshPlayer && !freshPlayer.isConnected) {
                freshPlayer.username = `Bot (was ${freshPlayer.username})`
                await freshGame.save()

                io?.to(`game-${freshGame.code}`).emit('player-replaced-by-bot', {
                  playerId: socket.data.userId,
                  botName: freshPlayer.username
                })
              }
            }, 60000)
          }
        }
      } catch (error) {
        console.error('Disconnect handler error:', error)
      }
    })
  })

  // Export io instance for use in API routes
  nitroApp.hooks.hook('request', (event) => {
    event.context.io = io
  })

  console.log('âœ… [SOCKET] Socket.IO server ready')
})

// Export for use in other files
export { io }
